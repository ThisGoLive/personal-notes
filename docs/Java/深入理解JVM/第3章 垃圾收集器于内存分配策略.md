[[TOC]]

# 第三章 垃圾收集器于内存分配策略

## 3.1 如何判断对象是否已死

### 3.1.1 引用计数算法

顾名思义，给对象添加一个引用计数器，当对象没又指向它的引用时，即为无用对象。

例如 Python 语言的GC

在 Java 无法，解决 循环引用的问题。

### 3.1.2 可达性分析算法 （GC Roots）

以 “GC Roots”的对象作为起始点，向下搜索，引用链，无法到达的对象即为 无用对象。

四类 GC Roots 对象：

+ 虚拟机栈中的引用对象
+ 方法区中静态属性的引用
+ 方法区中常量的引用
+ 本地方法栈中 JNI（Native方法）引用的对象

### 3.1.3 四种引用类型

强引用：

既正常的引用赋值。

软引用：

系统在发生 内存溢出（OOM）之前，会 gc 掉这部分对象

弱引用：

系统在最近的一次GC时，gc 掉这些对象

虚引用：

直接被垃圾回收标记

### 3.1.4 挽救

`finalize()` ,当对象被gc 之前，执行，如果引用有了，就挽救一次。当该对象第二次gc时，不会再触发。

## 3.2 垃圾收集算法

### 3.2.1 标记-清除

标记，清除，整理

后面两步效率都很低

### 3.2.2 复制算法

将内存分为两部，需要gc的对象，在移动过程中，被覆盖掉。

实现简单，效率高，消耗内存。

IBM：Eden (8) Survivor(1) Survivor(1)

### 3.2.3 标记 - 整理

标记，整理  而被GC的对象，在整理过程中被清除掉。

## 3.3 垃圾收集器

垃圾收集算法的实现

### 3.3.1 Serial收集器

串行：单线程。运行过程中需要停止下来进行GC

### 3.3.2 ParNew 收集器

Serial收集器的多线程版本

### 3.3.3 Parallel Scavenge 收集器

新生代的 收集器，复制算法

### 3.3.4 Serial Old收集器

老年代的收集器

### 3.3.5 Parallel  Old

### 3.3.6 CMS 收集器

使用的 标记 清除

初始标记 并发标记 重新标记 并非清除

### 3.3.7 G1 收集器

jdk 8 默认就是G1

+ 并行与并发
+ 分代收集
+ 空间整合
+ 可预测的停顿

### 

### 

