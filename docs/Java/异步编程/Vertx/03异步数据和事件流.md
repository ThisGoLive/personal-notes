# 异步数据和事件流

2024-01-30

## 1 概论

对于大多数事件，不能单独的处理，而是将其作为一个系列来处理。
例如 http 请求 得到 body ,处理需要多个 缓冲区。才能完成

## 2 统一的流模型

Vertx 提供了跨资源类型（文件、网络套接字）的各种流的统一抽象。

| 流资源          | 支持读 | 支持写 |
| --------------- | ------ | ------ |
| TCP 套接字      | 是     | 是     |
| UDP 数据包      | 是     | 是     |
| HTTP 请求与响应 | 是     | 是     |
| Websocket       | 是     | 是     |
| 文件            | 是     | 是     |
| SOL 结果        | 是     | 否     |
| Kafka 事件      | 是     | 是     |
| 周期定时器      | 是     | 否     |

主要接口 `io.vertx.core.streams.ReadStream` 和 `io.vertx.core.streams.WriteStream`

如果需要对接第三方异步事件，可以扩展实现这两个 API

异步流处理

```java
public class StreamDemo {

  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    OpenOptions options = new OpenOptions().setRead(true);
    vertx.fileSystem()
      // 读取
      .open("filename", options, event -> {
        if (event.succeeded()) {
          AsyncFile result = event.result();
          result
            // 读取成功
            .handler(System.out::println)
            // 失败异常处理
            .exceptionHandler(Throwable::printStackTrace)
            // 结束
            .endHandler(va -> vertx.close());
        } else {
          event.cause().printStackTrace();
        }
      })
      // 写入
      .open("", options, event -> {
        if (event.succeeded()) {
          AsyncFile result = event.result();
          result
            // 写入数据
            .write(Buffer.buffer(), 1L)
            .onSuccess(event2 -> {
            //   成功
              vertx.close();
            })
            // 失败异常处理
            .onFailure(Throwable::printStackTrace)
        } else {
          event.cause().printStackTrace();
        }
      });
  }
}
```

## 3 背压

背压是一种消费者机制： 当事件生产者的发送速率 高于 消费者的处理速率时，消费者可以向 生产者发送型号。

- ReadStream#pause 暂停流，阻止更多的数据发送到程序
- ReadStream#resume 恢复读取数据，并将数据发送给处理程序
- ReadStream#fetch 请求读取最多 nge 元素，在调用时，流必须处于暂停状态

- WriteStream#setWriteQueueMaxSize
  - 定义缓冲区写入队列的最大值，指的是队列中 vertx 缓冲区的个数，不是字节数，因为队列中各个缓冲区的大小不同
- WriteStream#writeQueueFull 判断缓冲区队列是否已满
- WriteStream#drainHandler 指定一个回调，当写缓冲区队列空出来（队列恢复为最大值的一半）回调

:::warning
即使队列长度，超过最大长度，还是可以进行写操作，并且会继续积累。
写入可以主动检查是否已满
当满时，再写。可以通过 drainHandler 通知写入放
:::

## 4 使用例子

[代码](https://github.com/jponge/vertx-in-action/tree/master/chapter4/src/main/java/chapter4/jukebox)

