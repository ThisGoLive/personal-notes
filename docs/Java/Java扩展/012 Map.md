# Map 相关问题

常见面试问题

https://mp.weixin.qq.com/s/nyJdRNi9Z7ZDIXYAqoMTZA

https://mp.weixin.qq.com/s/Pqhxq__KS40ZWiD-DVQ6Mg

https://mp.weixin.qq.com/s/fycrmmNtcKlfkaF-egejzw

https://juejin.cn/post/7077363148281348126

ConcurrentHashMap 抗ka ruen te

https://mp.weixin.qq.com/s/Vq2e4cCLH1KNV12Ar3Wlcg

[Java源码分析专题系列之【ConcurrentHashMap】全方位渗透的源码分析（JDK1.8版本） - 浩宇天尚-开源中国 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/liboware/blog/5117011)

### 扩容为什么两倍

默认长度 16 ，即  0000-11111 ，数据 只计算后面四位的 hash碰撞概率低。

同理 32 00000-11111 ，

容量与hash值进行计算的时候，采用的 & ，采用二进制倍数 可以有效减少 计算结构碰撞的问题。因为后四位碰撞的几率低，而不需要计算全部位数。

### 哈希算法

把任意长度Key 转换为固定长度Key，从而范围这个加快查询

 HashCode: 通过字符串算出 ascii 码，进行 取模 节省数组长度，所以 HashMap中 取模是 和 数组的长度进行，得到 在 table 数组中的 下表

首先底层通过调用hashCode方法生成初始hash值h1，然后将h1**无符号右移16位**得到h2，之后将h1与h2进行按位异或（^）运算得到最终hash值h3，之后将h3与(length-1)进行按位与（&）运算得到hash表索引

所以无符号右移16位的目的是使高混乱度地区与地混乱度地区做一个中和，提高低位的随机性，减少哈希冲突

### Hash碰撞

不同HashCode 取模得到 数组下标的相同，当相同时，就进行 头插法，成链表

## 为什么加载因子设置为0.75，初始化临界值是12

0.75是对空间和时间效率的一种平衡选择

如果负载因子小一些比如是0.4，那么初始长度16*0.4=6，数组占满6个空间就进行扩容，很多空间可能元素很少甚至没有元素，会造成大量的空间被浪费

如果负载因子大一些比如是0.9，这样会导致扩容之前查找元素的效率非常低

loadFactory越趋近于1，那么数组中存放的数据（entry也就越来越多），数据也就越密集，也就会有更多的链表长度处于更长的数值，我们的查询效率就会越低，当我们添加数据，产生hash冲突的概率也会更高

## 为什么Map桶中节点个数超过8才转为红黑树

树节点占用空间是普通Node的两倍，如果链表节点不够多却转换成红黑树，无疑会耗费大量的空间资源，并且在随机hash算法下的所有bin节点分布频率遵从泊松分布，链表长度达到8的概率只有0.00000006，几乎是不可能事件，所以8的计算是经过重重科学考量的

- 从平均查找长度来看，红黑树的平均查找长度是logn，如果长度为8，则logn=3，而链表的平均查找长度为n/4，长度为8时，n/2=4，所以阈值8能大大提高搜索速度

- 当长度为6时红黑树退化为链表是因为logn=log6约等于2.6，而n/2=6/2=3，两者相差不大，而红黑树节点占用更多的内存空间，所以此时转换最为友好
1. 当节点小于8时，链表和红黑树 查询差不多，但是 红黑树更加 浪费空间

2. 

### 扩容

扩容后 Hash下标： 16变32 其实知识 增加了一个 bit为， 计算为 0 即原本位置不变， 如果是1 即 原位置 + 16 即可。这里 变相 为扩容两倍 作为副证

## 为什么要在数组长度大于64之后，链表才会进化为红黑树

如果 链表长度 到达8 ，但是 数组长度 小于64 的情况下，效率反而不及 数组 + 链表，

在数组比较小时如果出现红黑树结构，反而会降低效率，而红黑树需要进行左旋右旋，变色，这些操作来保持平衡，同时数组长度小于64时，搜索时间相对要快些，总之是为了加快搜索速度，提高性能

## ConcurrentHashMap

### 添加

1. 是否需要初始 CAS 操作，一个线程进行初始化，因为 只有在Put 时才会

2. CAS 操作，获取Hash 对象 当前数组节点 ，

3. 获取成功 为空，CAS 操作，直接添加 返回，CAS  失败，进行下次操作

4. 不为空，是否在扩容

5. 没在扩容，就使用当前 节点为 锁对象， 即 分块锁

### 扩容

在扩容时，ConcurrentHashMap支持多线程并发扩容，在扩容过程中同时支持get查数据，若有线程put数据，还会帮助一起扩容。

有个 sizeCtl 进行控制，与 数组长度相关，如果 扩容 第一个位 会设置为 1 ，每个进而控制 各个线程 对 旧长度  进行计算，得到新旧 两个，还是 运用CAS 操作
