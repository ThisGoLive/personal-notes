[[TOC]]

# 6 容器的功能扩展  

前面几章已经基本了解：XML 到 实例化的bean的过程。但是这些过程中一直都是用的 BeanFactory 及 实现类 XmlBeanFactory。spring中对于工厂类的扩展，就是 `ApplicationContext`.

applectionContext 包含了 Beanfactory 的所有功能，以及它自己的功能。

由于spring4.0+支持 groovy,ecilpse 无法识别 groovy故而需要下载组件 [groovy组件](https://github.com/groovy/groovy-eclipse/wiki)

`ApplicationContext`需要的spring包：core 、beans 、beans-groovy、aop 、context、expression、instrument

构建方式：

```java
BeanFactory bf = new XmlBeanFactory(new ClassPathResource("./META-INF/test.xml"));
ApplicationContext cont = new ClassPathXmlApplicationContext("test.xml");


public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
		this(new String[] {configLocation}, true, null);// 调用 构造
	}
public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException {

		super(parent);
    // 路径选择
		setConfigLocations(configLocations);
		if (refresh) {
            // 功能扩展
			refresh();
		}
	}
```

## 6.1 路径

```java
	public void setConfigLocations(String... locations) {
		if (locations != null) {
			Assert.noNullElements(locations, "Config locations must not be null");
			this.configLocations = new String[locations.length];
			for (int i = 0; i < locations.length; i++) {
                // 解析 路径， 如果类似 ${} 则会搜寻匹配的系统遍变量进行替换
				this.configLocations[i] = resolvePath(locations[i]).trim();
			}
		}
		else {
			this.configLocations = null;
		}
	}
```

## 6.2 扩展功能

获取到类对应的配置文件路径，refresh函数中几乎包含了ApplicationContext的全部功能。

```java
public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
            // 准备刷新 上下文环境
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
            // 初始化 BeanFactory ，并进行XML的读取
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
            // 对 BeanFactory 的功能填充
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
                // 子类覆盖方法 做额外的处理
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
                //  激活 beanFactory 中的各种处理器。
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
                // 注册拦截bean的bean处理器 这里只是注册 正在调用在 getBean中
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
                // 为上下文 初始化 message源，即不用的消息体，国际化处理。
				initMessageSource();

				// Initialize event multicaster for this context.
                // 初始化消息广播器，放入 ApplicationEventMulticaster 实例中
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
                // 留给子类 ；来初始化其他的bean
				onRefresh();

				// Check for listener beans and register them.
                // 在所有注册的bean中查找 ListenerBean 注册到消息广播器中
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
                // 初始化剩下的单例bean（非惰性）
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
                // 完成刷新过程，通知生命周期处理器 lifecycleProcessor 刷新过程
                // 并发出ContexRefreshEvent通知别人
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
```

1. 初始化前的准备工作，如对系统属性 或者环境变量的 准备和验证
2. 初始化Beanfactory 并进行 XML的读取，这里之后就可以完成 Beanfactory的实现，可以创建bean了。
3. 对Beanfactory 的各种功能的实现
4. 子类覆盖方法 做额外的处理
5. 激活各种 Beanfactory处理器
6. 注册拦截bean创建的bean处理器

...

## 6.3 环境准备

```java
	protected void prepareRefresh() {
		this.startupDate = System.currentTimeMillis();
		this.closed.set(false);
		this.active.set(true);

		if (logger.isInfoEnabled()) {
			logger.info("Refreshing " + this);
		}

		// Initialize any placeholder property sources in the context environment
        // 留给子类覆盖 
		initPropertySources();

		// Validate that all properties marked as required are resolvable
		// see ConfigurablePropertyResolver#setRequiredProperties
        // 用于验证需要的属性文件是否已经放入环境中
		getEnvironment().validateRequiredProperties();

		// Allow for the collection of early ApplicationEvents,
		// to be published once the multicaster is available...
		this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();
	}
```

验证：

```java
@Override
initPropertySources(){
	getEnvironment().setRequiredProperties("...");
};
```

## 6.4 加载BeanFactory  obtainFreshBeanFactory

`ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();`

```java
protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    // 初始化Beanfactory，对XML进行读取，并加载到当前实体中
		refreshBeanFactory();
    // 返回当前实体的beanFactory属性
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (logger.isDebugEnabled()) {
			logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);
		}
		return beanFactory;
	}
```

`refreshBeanFactory();`来完成核心实现

```java
	protected final void refreshBeanFactory() throws BeansException {
		if (hasBeanFactory()) {
			destroyBeans();
			closeBeanFactory();
		}
		try {
            // 创建 DefaultListableBeanFactory
			DefaultListableBeanFactory beanFactory = createBeanFactory();
            
            // 为了序列化指定id 如果需要的化 让这个beanfactory从 id 反序列化到BeanFactory 对象
			beanFactory.setSerializationId(getId());
            // 定制 beanFactory 设置相关属性 包括是否允许 覆盖同名称 不同定义的对象 以及循环依赖
            // 设置 Autowired 和 Qualifier 注解解析器
			customizeBeanFactory(beanFactory);
            // 初始化 DodumentReader 并进行XML文件读取 与 解析
			loadBeanDefinitions(beanFactory);
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;
			}
		}
		catch (IOException ex) {
			throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
		}
	}
```

1. 创建DefaultListableBeanFactory：`DefaultListableBeanFactory`提供了reader属性，也就是容器的基础，需要首先实例化。
2. 指定序列号 id
3. 定制 Beanfactory
4. 加载BeanDefinition
5. 使用全局变量记录Beanfactory的实例

### 6.4.1 定制BeanFactory

这里已经开始对 Beanfactory的扩展了。`customizeBeanFactory(beanFactory);`

```Java
protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {
    // 如果不为空 设置Beanfactory对象 相应的属性
    // 属性含义：是否允许 同名 不同类型的对象 覆盖
		if (this.allowBeanDefinitionOverriding != null) {
			beanFactory.setAllowBeanDefinitionOverriding
                (this.allowBeanDefinitionOverriding);
		}
    // 如果不为空 设置 对应属性
    // 是否允许 bean之间的循环依赖
		if (this.allowCircularReferences != null) {
			beanFactory.setAllowCircularReferences(this.allowCircularReferences);
		}
    // 以上两个值（allowBeanDefinitionOverriding 、allowCircularReferences） 都是没有的 
    // 换句话 就是 没起作用  如果要使用 需要 自定义 context 重写customizeBeanFactory方法
    // 将这两个值 setter 为 不为空状态即可 
    // 3.x 有对Autowired 和 Qualifier 的设置 4.3.x怎么没有 
    // 也就是说 这里 没有 对 autowire 和Qualifier 注解 设置
	}
```

在上一章 的加载 bean 时， autowireByType 方式注入：默认使用 spring 的SimpleAutowireCandidateResolver，而对于默认的实现没有 过多的逻辑处理。这里（3.x），`beanFactory.setAutowireCandidateResolver( new  QualifierAnnotationAutowireCandidateResolver )`,设置了解析器后就可以 支持注解方式 的注入

```java

// QualifierAnnotationAutowireCandidateResolver 提供的解析 autowire 和 Qualifier 的方法
public Object getSuggestedValue(DependencyDescriptor descriptor) {
		Object value = findValue(descriptor.getAnnotations());
		if (value == null) {
			MethodParameter methodParam = descriptor.getMethodParameter();
			if (methodParam != null) {
				value = findValue(methodParam.getMethodAnnotations());
			}
		}
		return value;
	}

```

### 6.4.2 加载BeanDefinition

6.4.1 已经实例化了DefaultListableBeanFactory，然后需要XMLBeanDefinitionReader来读取XML

```java
	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
		// Create a new XmlBeanDefinitionReader for the given BeanFactory.
        // 指定 Beanfactory 创建 XMLBeanDefinitionReader
		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

		// Configure the bean definition reader with this context's
		// resource loading environment.
        // 对 XMLBeanDefinitionReader 设置环境变量
		beanDefinitionReader.setEnvironment(this.getEnvironment());
		beanDefinitionReader.setResourceLoader(this);
		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

		// Allow a subclass to provide custom initialization of the reader,
		// then proceed with actually loading the bean definitions.
        // 对 XMLBeanDefinitionReader 设置 可以进行覆盖
		initBeanDefinitionReader(beanDefinitionReader);
        
		loadBeanDefinitions(beanDefinitionReader);
	}
```

`loadBeanDefinitions(beanDefinitionReader);`对文件的读取

```java
	protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
		Resource[] configResources = getConfigResources();
		if (configResources != null) {
			reader.loadBeanDefinitions(configResources);
		}
		String[] configLocations = getConfigLocations();
		if (configLocations != null) {
			reader.loadBeanDefinitions(configLocations);
		}
	}
```

这里内部 基本就是 之前 几章 的内容，不过XMLBeanDefinitionReader 读取的Handler 是存在与 DefaultListableBeanFactory 中的。DefaultListableBeanFactory中的 Beanfactory  变量已经配置完成类了。

## 6.5 功能的扩展 功能填充

进入 6.2 中 的 `prepareBeanFactory(beanFactory);`功能填充，ApplicationContext的主要功能 也就在这里

```Java
	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		// Tell the internal bean factory to use the context's class loader etc.
        // 设置当前 Beanfactory 的 classLoader 为当前context 的 classLoader
		beanFactory.setBeanClassLoader(getClassLoader());
        
        // 1 设置 beanFactory 的表达式语言处理器 ，spring 3中添加的功能
        // ${bean.xx} 处理相关属性
		beanFactory.setBeanExpressionResolver(
            new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
        
       	// 2 为Beanfactory设置一个默认的propertyEditor，主要是对bean属性等设置管理的一个工具
		beanFactory.addPropertyEditorRegistrar(
            new ResourceEditorRegistrar(this, getEnvironment()));

		// Configure the bean factory with context callbacks.
        //3  添加后置处理器 AwareProcessor
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
		// 4 设置几个忽略自动装配的接口
        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

		// BeanFactory interface not registered as resolvable type in a plain factory.
		// MessageSource registered (and found for autowiring) as a bean.
        // 5 设置忽略自动装配的特殊规则
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

		// Register early post-processor for detecting inner beans as ApplicationListeners.
        // 6 添加后置处理器 用于监测bean内部的 ApplicationListener
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

		// Detect a LoadTimeWeaver and prepare for weaving, if found.
        // 7 添加对 AspectJ 的支持 （切面）
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		// Register default environment beans.
        // 8 添加默认的系统环境 bean
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
	}
```

1. 增加对SPEL语言的支持
2. 增加对属性编辑器的支持
3. 增加对一些内置类，如 EnvironmentAware MessageSourceAware 信息注入
4. 设置 依赖功能 可忽略接口
5. 注册一些固定依赖属性
6. ApplicationListener （在spring 3中没有的）
7. 增加对切面 AspectJ 的支持
8. 将相关环境变量，及属性注册 以单例 模式注入

### 6.5.1 增加SPEL语言支持

SPEL： Spring Expression Language，类似Struts 2x中的OGNL语言表达式。SPEL 只依赖于 core ，不依赖其他模块。可以单独使用。

大致使用：

```xml
<bean id="bean1" class="xxx.xxx"/>
<bean id="bean2" class="xxx">
	<property name="bean" value="#{bean1}"/>
</bean>
<!-- 等同于 -->
<bean id="bean2" class="xxx">
	<property name="bean" ref="bean1"/>
</bean>
```

`beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));`设置，注册了解析器。

在bean初始化的时候，填充属性时，spring 会调用 AbstractCapableBeanFactory 类中的 applyPropertyValues函数完成功能，再构造BeanDefinitionValueResolver 实例 调用 valueResolver 对属性值解析，这里一般会调用 AbstractBeanFactory的 evaluateBeanDefinitionString 完成SPEL 解析，这里就会判断 `StandardBeanExpressionResolver`是否存在。

### 6.5.2 增加属性注册编辑器

`beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));`

spring 注入时 可以把普通 类型 的属性注入，但是 复杂点的 就不能：

```java
public class Test{
    private Date time;
}
```

```xml 
<bean id="test" class="Test">
	<property name="time">
        <value>2018-08-08</value>
    </property>
</bean>
```

这时是无法注入的。类型不对。

#### 6.5.2.1 自定义 属性编辑器

继承PropertyEditorSupport，重写 serAsText。

```java
public class MyCustomEditors extends PropertyEditorSupport {

	@Override
	public void setAsText(String va) {
		// 自定义解析 如 2018-08-08 转换层 Date
        this.setValue 
	}
}
```

注册 自定义编辑器

```xml
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
	<property name="customEditors">
        <map>
        	<entry key="java.util.Date">
            	<bean class="xxx.MyCustomEditors">
                <!-- 同正常bean 一样 可以注入属性-->
                </bean>
            </entry>
        </map>
    </property>
</bean>
```

意思，就是 当spring解析时遇到 了 `java.util.Date`类型，会调用MyCustomEditors类实例 进行 属性注入。

#### 6.5.2.2 spring自带的 属性编辑器 CustomDateEditor

`org.springframework.beans.propertyeditors`spring自带的 date属性编辑器。

唯一做的，就是 自定义 一个类 

```java
public class DateProperty implements PropertyEditorRegistrar{
    public void registerCustomEditors(PropertyEditorRegistry registry){
        registry.registerCustomEditor(Date.class,
                                      new CutomDateEditor
                                      (new SimpleDateFormat("yyyy-MM-dd"),true));
    }
}
```

注册 spring 自带的编辑器：

```xml
<bean class="org.Springframework.beans.factory.config.CustomEditorConfigurer">
	<property name="propertyEditorRegistrars">
        <list>
        	<bean class="上面自定义bean的DateProperty"></bean>
        </list>
    </property>
</bean>
```

看逻辑，应该是：我们自定义的 bean 只是一个媒介，规定了 `PropertyEditorRegistry`类在处理 Date类型 时 调用 ` new CutomDateEditor`，而处理方式"yyyy-MM-dd"。配置时，只是将 自定义bean 配置到 类似 自定义的 配置 文件中。 

但是，貌似 和 本机 `beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));`没有联系。自定义类中 是 `registerCustomEditor`进行的注册，而 `addPropertyEditorRegistrar`才是注册

由于  里面的代码 比较 无聊。大致的意思：PropertyEditorRegistry类中 注册有了 基本 的解析器，而自定义的，也添加了。



### 6.5.3 添加处理器  ApplicationContextAwareProcessor

`beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));`添加类后置处理器，在init-method 中前后才会用到的。

```java
	// 前置处理器
	public Object postProcessAfterInitialization(Object bean, String beanName) {
		return bean;
	}

	// 后置处理器 主要是这个
	public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
		AccessControlContext acc = null;

		if (System.getSecurityManager() != null &&
				(bean instanceof EnvironmentAware || 
                 bean instanceof EmbeddedValueResolverAware ||
                 bean instanceof ResourceLoaderAware || 
                 bean instanceof ApplicationEventPublisherAware ||
                 bean instanceof MessageSourceAware || 
                 bean instanceof ApplicationContextAware)) {
			acc = this.applicationContext.getBeanFactory().getAccessControlContext();
		}

		if (acc != null) {
			AccessController.doPrivileged(new PrivilegedAction<Object>() {
				@Override
				public Object run() {
					invokeAwareInterfaces(bean);
					return null;
				}
			}, acc);
		}
		else {
			invokeAwareInterfaces(bean);
		}

		return bean;
	}
	// 实现 对应Aware 接口 就会获取对应的 资源 如ApplicationEventPublisherAware 接口 ，就会setApplicationEventPublisher
	private void invokeAwareInterfaces(Object bean) {
		if (bean instanceof Aware) {
			if (bean instanceof EnvironmentAware) {
				((EnvironmentAware) bean).
                    setEnvironment(this.applicationContext.getEnvironment());
			}
			if (bean instanceof EmbeddedValueResolverAware) {
				((EmbeddedValueResolverAware) bean).
                    setEmbeddedValueResolver(this.embeddedValueResolver);
			}
			if (bean instanceof ResourceLoaderAware) {
				((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
			}
			if (bean instanceof ApplicationEventPublisherAware) {
				((ApplicationEventPublisherAware) bean).
                    setApplicationEventPublisher(this.applicationContext);
			}
			if (bean instanceof MessageSourceAware) {
				((MessageSourceAware) bean).setMessageSource(this.applicationContext);
			}
			if (bean instanceof ApplicationContextAware) {
				((ApplicationContextAware) bean).
                    setApplicationContext(this.applicationContext);
			}
		}
	}
```

### 6.5.4 设置忽略依赖

在上一步中，设置了对应的Aware后，忽略 注册对应的Aware的 接口

### 6.5.5 注册依赖

检查到BeanFactory类型，便会将BeanFactory的实例注入。

## 6.6 BeanFactory 的后置处理

第二节 `postProcessBeanFactory(beanFactory);`开始 到后面 都有

### 6.6.1 激活注册的 BeanFactoryPostProcessor （后置处理器）

BeanFactoryPostProcessor 与BeanPostProcessor  类似，都可以对Bean实例进行处理，Spring IOC 容器 允许BeanFactoryPostProcessor 在容器实例化 其他Bean时，读取元数据，并且可以修改。可以设置多个，并用order 属性（只有实现类Order接口）控制执行顺序。

BeanFactoryPostProcessor 只会对 所在定义在的 容器中有效。

#### 6.6.1.1 BeanFactoryPostProcessor 的应用 ： PropertyPlaceholderConfigurer （引入外文件）

在spring配置中，经常出现 变量引用。

```xml
<bean>
	<property name="name">
    	<value>${bean.name}</value>
    </property>
</bean>
```

` ${bean.name}`这个值往往可以放在其他的文件中。如 bean.propertites : bean.name=xiaoming

那么spring是怎么识别寻找到 bean.propertites的呢？

就是用到类 `PropertyPlaceholderConfigurer` ：

```xml
<bean id="configurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
	<property name="locations">
    	<list>
        	<value>bean.propertites(路径)</value>
        </list>
    </property>
</bean>
```

PropertyPlaceholderConfigurer 这个类貌似 只是 spring容器管理的一个普通类。但是实际上就是实现了      BeanFactoryPostProcessor 接口。而这个接口，在spring 加载任何实现了该接口的类的时候，都会在bean工厂载入所有的bean的配置 之后，去调用postProcessBeanFactory，

而PropertyPlaceholderConfigurer实现了 postProcessBeanFactory。并调用了三个方法：

```java
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		try {
			Properties mergedProps = mergeProperties();

			// Convert the merged properties, if necessary.
			convertProperties(mergedProps);

			// Let the subclass process the properties.
			processProperties(beanFactory, mergedProps);
		}
		catch (IOException ex) {
			throw new BeanInitializationException("Could not load properties", ex);
		}
	}
```

这三个方法，分别得到配置，将数据转换为合适的类型，提供给BeanFactory使用。

#### 6.6.1.2 使用自定义的 BeanFactoryPostProcessor

即自定义的 类 实现 接口BeanFactoryPostProcessor。重写postProcessBeanFactory。

```java
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor  {

	private Set<String> set ;
	
	public  MyBeanFactoryPostProcessor() {
		this.set = new HashSet<>();
	}
	
	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		String[] strings = beanFactory.getBeanDefinitionNames();
		for (String string : strings) {
			BeanDefinition bd = beanFactory.getBeanDefinition(string);
			// 处理 对应的数据
			BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(new StringValueResolver() {
				
				@Override
				public String resolveStringValue(String strVal) {
					if (set.contains(strVal)) return "***";
					return strVal;
				}
			});
			visitor.visitBeanDefinition(bd);
		}
	}

	public Set<String> getSet() {
		return set;
	}

	public void setSet(Set<String> set) {
		this.set = set;
	}
}
// 测试 bean
public class NewBean {

	private String item1;
	private String item2;
	private String item3;
	@Override
	public String toString() {
		return "NewBean [item1=" + item1 + ", item2=" + item2 + ", item3=" + item3 + "]";
	}
}

```

```xml
<!-- 自定义 PostProcessBeanFactory -->
	<bean id="process" class="com.postProcess.MyBeanFactoryPostProcessor">
		<property name="set">
			<set>
				<value>政府</value>
				<value>共产党</value>
			</set>
		</property>
	</bean>
	<bean id="nb" class="com.postProcess.NewBean">
		<property name="item1" value="政府"></property>
		<property name="item2" value="共产党"></property>
		<property name="item3" value="没屏蔽"></property>
	</bean>
```

```java
Resource resource = new ClassPathResource("./META-INF/test.xml");
BeanFactory bf = new XmlBeanFactory(resource);
ApplicationContext cont = new ClassPathXmlApplicationContext("./META-INF/test.xml");

cont.getBean("process");
System.out.println(cont.getBean("nb"));
// 输出 ： NewBean [item1=***, item2=***, item3=没屏蔽]

bf.getBean("process");
System.out.println(bf.getBean("nb"));
// 就没有屏蔽掉  NewBean [item1=政府, item2=共产党, item3=没屏蔽]
```

MyBeanFactoryPostProcessor 就相当于屏蔽掉 敏感词。

#### 6.6.1.3 激活BeanFactoryPostProcessor

前面1 2点 都是 对 `postProcessBeanFactory(beanFactory);`的梳理。

3点则是：`invokeBeanFactoryPostProcessors(beanFactory);`

又由于4.3.x 与 3.x 版本问题，这里又出现了较大的差异。均用 4.3.x 

```java
	protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
		PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

		// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
		// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
		if (beanFactory.getTempClassLoader() == null &&
            beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor
                (new LoadTimeWeaverAwareProcessor(beanFactory));
			beanFactory.setTempClassLoader
                (new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}
	}
```

这里面的代码 貌似和 3.x 类似。

```java
	public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

		// Invoke BeanDefinitionRegistryPostProcessors first, if any.
		Set<String> processedBeans = new HashSet<String>();

        // 对 BeanDefinitionRegistry 类进行处理 bean注册表定义
        // 分为 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor
		if (beanFactory instanceof BeanDefinitionRegistry) {
			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
            
			List<BeanFactoryPostProcessor> regularPostProcessors = 
                						new LinkedList<BeanFactoryPostProcessor>();
			List<BeanDefinitionRegistryPostProcessor> registryProcessors = 
                				new LinkedList<BeanDefinitionRegistryPostProcessor>();

            // 对 beanFactory 的后置处理器们 进行处理  硬编码注册的后置处理器
			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
					BeanDefinitionRegistryPostProcessor registryProcessor =
							(BeanDefinitionRegistryPostProcessor) postProcessor;
                    
                    // BeanDefinitionRegistryPostProcessor 类型的，
                    // 在BeanFactoryPostProcessor的基础上，还有一定自己的定义方法。 先调用
					registryProcessor.postProcessBeanDefinitionRegistry(registry);
					registryProcessors.add(registryProcessor);
				}
				else {
                    // 不是BeanDefinitionRegistryPostProcessor类，即常规类型，就直接添加进集合。
					regularPostProcessors.add(postProcessor);
				}
			}

			// Do not initialize FactoryBeans here: We need to leave all regular beans
            // 这里不要初始化FaseBebean：我们需要离开所有常规bean
			// uninitialized to let the bean factory post-processors apply to them!
            // 未初始化，让 bean 工厂 后处理器 应用于他们！ 
			// Separate between BeanDefinitionRegistryPostProcessors that implement
            // 那是在单独的执行beandefinitionregistrypostprocessors 
			// PriorityOrdered, Ordered, and the rest.
            // 优先级，有序，其余的。
            
			List<BeanDefinitionRegistryPostProcessor> currentRegistryProcessors = 
                				new ArrayList<BeanDefinitionRegistryPostProcessor>();

			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
            // 首先：BeanDefinitionRegistryPostProcessors 调用 PriorityOrdered 实施
            // 获取配置中 所有的 BeanDefinitionRegistryPostProcessor 类的 实例 名称 进行处理
			String[] postProcessorNames = beanFactory.getBeanNamesForType
                			(BeanDefinitionRegistryPostProcessor.class, true, false);
            
            // 遍历 处理器 中 PriorityOrdered类型的，进行处理
			for (String ppName : postProcessorNames) {
				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
            // 对 currentRegistryProcessors 集合中 
            // BeanDefinitionRegistryPostProcessor 进行 优先级排序
			sortPostProcessors(currentRegistryProcessors, beanFactory);
            
			registryProcessors.addAll(currentRegistryProcessors);
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
            // 然后就是 BeanDefinitionRegistryPostProcessors 的 Ordered 类型 同样是上面类逻辑
			postProcessorNames = beanFactory.getBeanNamesForType
                			(BeanDefinitionRegistryPostProcessor.class, true, false);
			for (String ppName : postProcessorNames) {
				if (!processedBeans.contains(ppName) && 
                    beanFactory.isTypeMatch(ppName, Ordered.class)) {
					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
					processedBeans.add(ppName);
				}
			}
            // 排序
			sortPostProcessors(currentRegistryProcessors, beanFactory);
            // 添加
			registryProcessors.addAll(currentRegistryProcessors);
            // 运用
			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
			currentRegistryProcessors.clear();

			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
            // 最后： 调用所有其他BeaDealixReistyPress处理器，直到没有其他的处理器出现。
			boolean reiterate = true;
			while (reiterate) {
				reiterate = false;
				postProcessorNames = beanFactory.getBeanNamesForType
                    			(BeanDefinitionRegistryPostProcessor.class, true, false);
				for (String ppName : postProcessorNames) {
					if (!processedBeans.contains(ppName)) {
						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
						processedBeans.add(ppName);
						reiterate = true;
					}
				}
                // 排序
				sortPostProcessors(currentRegistryProcessors, beanFactory);
                // 再次加入 总的
				registryProcessors.addAll(currentRegistryProcessors);
				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
				currentRegistryProcessors.clear();
			}

			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.
            // 现在，调用到目前为止postProcessBeanFactory 处理的所有处理器的 回调
			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
		}
// 不是 BeanDefinitionRegistry 类型的 工厂类 直接调用 注册
		else {
			// Invoke factory processors registered with the context instance.
            // 调用与上下文实例注册的工厂处理器
			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
		}

		// DonotinitializeFactoryBeanshere： Weneed同leaveallregular北安市
		// uninitialized to let the bean factory post-processors apply to them!
		String[] postProcessorNames =
				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
		List<String> orderedPostProcessorNames = new ArrayList<String>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
        
        // 对后置处理器 进行分类
		for (String ppName : postProcessorNames) {
			if (processedBeans.contains(ppName)) {
				// 已经处理过的
			}
			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
        // 按照 优先级 排序
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.
		List<BeanFactoryPostProcessor> orderedPostProcessors = 
            							new ArrayList<BeanFactoryPostProcessor>();
		for (String postProcessorName : orderedPostProcessorNames) {
			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

		// Finally, invoke all other BeanFactoryPostProcessors.
        // 无序 直接调用
		List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
		for (String postProcessorName : nonOrderedPostProcessorNames) {
			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
		}
		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

		// Clear cached merged bean definitions since the post-processors might have
		// modified the original metadata, e.g. replacing placeholders in values...
		beanFactory.clearMetadataCache();
	}

```

1. 先 判断 工厂实例 是否是 BeanDefinitionRegistry 类型
2. 是的话分类 并对 后置处理中 为 BeanDefinitionRegistryPostProcessor 类型的，使用自身 实现的方法，并加载到集合 registryProcessors ，不是的直接加载到 regularPostProcessors 。
3. 将 工厂类 是PriorityOrdered 类型的，得到它的 BeanDefinitionRegistryPostProcessor 。添加进集合currentRegistryProcessors ，并记录名称。排序，加载到 registryProcessors ，invoke。
4. 将 工厂类 是Ordered 类型的，得到它的 BeanDefinitionRegistryPostProcessor 。添加进集合currentRegistryProcessors ，并记录名称。排序，加载到 registryProcessors ，invoke。
5. 将 工厂类 中其余的 也遍历一次 ，得到它的 BeanDefinitionRegistryPostProcessor。添加进集合currentRegistryProcessors ，并记录名称。排序，加载到 registryProcessors ，invoke。
6. 不是 BeanDefinitionRegistry ，直接注册，而不会去寻找它的 BeanDefinitionRegistryPostProcessor  类型。

判断之外的：

1. 得到工厂类 全部 的 BeanFactoryPostProcessor 名称
2. 在之前记录了的（在processedBeans 中的），就不会。再分类， PriorityOrdered  类型：加载到priorityOrderedPostProcessors 集合中，Ordered 类型 名称加载到orderedPostProcessorNames 中，剩下的名称加载到nonOrderedPostProcessorNames 
3. 对 PriorityOrdered 类型，priorityOrderedPostProcessors 集合处理。
4. 加载 Ordered类型的BeanFactoryPostProcessor 加载到 orderedPostProcessors 集合处理。
5. 对剩下的nonOrderedPostProcessors 集合中的 BeanFactoryPostProcessor 进行处理。

### 6.6.2 注册 BeanPostProcessor Bean后置处理器

上文是 BeanFactoryPostProcessors的 调用，这里则就是 BeanPostProcessor 的注册，真正调用是在bean的实例化时调用的。这个步骤很重要，但很多功能 BeanFactory 不支持的原因，而applicationContet支持。因为大部分功能是通过后置处理器注册扩展的，但是BeanFactory 并没有实现 自动注册。applicationContet则是实现了自动注册。

`registerBeanPostProcessors(beanFactory);`6.2 中的步骤

自定义 后置处理器：

```java
public class MyInstantationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {

	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		System.out.println("每次用applicationContext getBean时都会执行~");
		return null;
	}
	// 还有其他方法 需要实现，并且返回不要是null
}
```

```xml
<bean class="com.wareBeanPostProcessor.MyInstantationAwareBeanPostProcessor"></bean>
```

代码：

```java
protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
		PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
	}
```

```java
public static void registerBeanPostProcessors(
			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

		// Register BeanPostProcessorChecker that logs an info message when
    	// BeanPostProcessorChecker是一个普通的打印信息
		// a bean is created during BeanPostProcessor instantiation, i.e. when
    	// bean在后置处理器实例化过程中创建 
		// a bean is not eligible for getting processed by all BeanPostProcessors.
    	// bean没有资格被所有bean后置处理器处理 
    	// 打印信息
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
    	// 区分开 实现 PriorityOrdered 的排序 与 其余的
		List<BeanPostProcessor> priorityOrderedPostProcessors = 
            										new ArrayList<BeanPostProcessor>();
		List<BeanPostProcessor> internalPostProcessors = 
            										new ArrayList<BeanPostProcessor>();
    	// 使用 Ordered 保证排序
		List<String> orderedPostProcessorNames = new ArrayList<String>();
    	// 无序时
		List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
    
    	// 将后置处理器 按照 由于与无序 保存
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				BeanPostProcessor pp = 
                    				beanFactory.getBean(ppName, BeanPostProcessor.class);
				priorityOrderedPostProcessors.add(pp);
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);
				}
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, register the BeanPostProcessors that implement PriorityOrdered.
    	// 第一 注册所有实现 PriorityOrdered 的 BeanPostProcessors
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

		// Next, register the BeanPostProcessors that implement Ordered.
    	// 在注册 实现Ordered 的BeanPostProcessors
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();
		for (String ppName : orderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			orderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);

		// Now, register all regular BeanPostProcessors.
    	// 第三 注册 所有无序的 BeanPostProcessors
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();
		for (String ppName : nonOrderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			nonOrderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

		// Finally, re-register all internal BeanPostProcessors.
    	// 第四 重新注册 所有 内部的 BeanPostProcessors
		sortPostProcessors(internalPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, internalPostProcessors);

		// Re-register post-processor for detecting inner beans as ApplicationListeners,
    	// 重新注册用于检测内部bean作为应用侦听器的后置处理器， 
		// moving it to the end of the processor chain (for picking up proxies etc).
    	// 将其移动到处理器链的末端（用于拾取代理等）
		beanFactory.addBeanPostProcessor
            						(new ApplicationListenerDetector(applicationContext));
	}
```

我们发现 BeanPsotProcessors 与 BeanFactoryPostProcessors 注册类似。但是 BeanFactoryPostProcessors 有两种方式，硬编码注册 和 配置文件注册。但BeanPostProcessors，只是需要注册，而不需要马上调用，故而只是 配置文件注册。

### 6.6.3 初始化消息资源

6.2 中 `initMessageSource();`

i18n国际化。一般需要连个条件：语言类型 和 国家/地区类型。

Java 中的 本地化对象类：Java.util.Locale

```java
Locale l1 = new Locale("zh","CN");
Locale l2 = new Locale("zh");
Locale l3 = Locale.CHINA;
Locale l4 = Locale.CHINESE;
Locale l = Locale.getDefaule();
```

Spring 中 基本 就是 对Java原生进行的支持，并且，配置不同 的语言 cont.getMessage(,,);

### 6.6.4 初始化 ApplicationEventMulticaster 事件传播器

6.2中 `initApplicationEventMulticaster();`

1. 自定义 springApplication的事件 继承applicationEvent

```java
public class MyAppEvent extends ApplicationEvent {
	public String str;
	public MyAppEvent(Object source) {
		super(source);
	}
	public MyAppEvent(Object source,String st) {
		super(source);
		this.str = st;
	}
	public void doing() {
		System.out.println("事件内容：" + str);
	}
}
```

2. 定义监听器 实现 ApplicationListenter

```java
public class MyAppListener implements ApplicationListener<MyAppEvent> {
	@Override
	public void onApplicationEvent(MyAppEvent event) {
		if (event != null)
			event.doing();
	}
}
```

3. 配置文件

```xml
<bean id="testList" class="com.applicationEvent.MyAppListener"></bean>	
```

4. 调用

```java
// 自定义 Application事件
cont.publishEvent(new MyAppEvent("11", "252"));
```

源码：

当用户有 自定义 事件广播器时 使用 用户自定义的。 没有的化，使用ApplicationEventMulticaster（上例 就是没有 自定义 事件广播器）

```java
	protected void initApplicationEventMulticaster() {
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        
		if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
			this.applicationEventMulticaster =
					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
			if (logger.isDebugEnabled()) {
				logger.debug("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
			}
		}
		else {
			this.applicationEventMulticaster = 
                					new SimpleApplicationEventMulticaster(beanFactory);
			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
			if (logger.isDebugEnabled()) {
				logger.debug("Unable to locate ApplicationEventMulticaster with name '" +
						APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
						"': using default [" + this.applicationEventMulticaster + "]");
			}
		}
	}
```

```java
	// SimpleApplicationEventMulticaster类中 的multicastEvent方法处理 广播事件，并使用事件中的onApplicationEvent 进行事件的处理。
	@Override
	public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
		ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
		for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
			Executor executor = getTaskExecutor();
			if (executor != null) {
				executor.execute(new Runnable() {
					@Override
					public void run() {
						invokeListener(listener, event);
					}
				});
			}
			else {
				invokeListener(listener, event);
			}
		}
	}
```

### 6.6.5 注册监听器

6.2 中 `registerListeners();`

```java
	protected void registerListeners() {
		// Register statically specified listeners first.
        // 硬编码方式 注册监听器
		for (ApplicationListener<?> listener : getApplicationListeners()) {
			getApplicationEventMulticaster().addApplicationListener(listener);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let post-processors apply to them!
        // 配置文件方式 注册 监听器
		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
		for (String listenerBeanName : listenerBeanNames) {
			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
		}

		// Publish early application events now that we finally have a multicaster...
		Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
		this.earlyApplicationEvents = null;
		if (earlyEventsToProcess != null) {
			for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
				getApplicationEventMulticaster().multicastEvent(earlyEvent);
			}
		}
	}
```

## 6.7 初始化非延迟加载

`finishBeanFactoryInitialization(beanFactory);`

```java
	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
		// Initialize conversion service for this context.
		if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
				beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
			beanFactory.setConversionService(
					beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
		}
		// Register a default embedded value resolver if no bean post-processor
		// (such as a PropertyPlaceholderConfigurer bean) registered any before:
		// at this point, primarily for resolution in annotation attribute values.
		if (!beanFactory.hasEmbeddedValueResolver()) {
			beanFactory.addEmbeddedValueResolver(new StringValueResolver() {
				@Override
				public String resolveStringValue(String strVal) {
					return getEnvironment().resolvePlaceholders(strVal);
				}
			});
		}
		// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
		String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
		for (String weaverAwareName : weaverAwareNames) {
			getBean(weaverAwareName);
		}

		// Stop using the temporary ClassLoader for type matching.
		beanFactory.setTempClassLoader(null);
		// 冻结 所有的Bean定义 说明注册的bean定义将步被修改 或者任何再处理
		beanFactory.freezeConfiguration();
		// 初始化 剩下的单例（非惰性的）
		beanFactory.preInstantiateSingletons();
	}
```

### 6.7.1 ConversionService 的设置

之前有对与 String类型转换 成Date 类型。还可以这么实现 Converter.

自定义 转换器

```java
public class StringToDate implements Converter<String,Date>{
    @Override
    public Date convert(String str){
        ... 转换逻辑 可转换成任意需要的类型
    }
}
```

```xml 
	<!-- String 转  Date Convert ID 必须为 conversionService -->
<bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
    	<list>
        	<bean class="com.converterStringToDate.StringToDate"></bean>
        </list>
    </property>
	</bean>
	<bean id="time" class="com.converterStringToDate.TestDateBean">
		<property name="da" value="2011-1-1"></property>
	</bean>
```

使用：直接 getBean，正常使用。

### 6.7.2 冻结配置

`beanFactory.freezeConfiguration();`

### 6.7.3 初始化 非延迟加载

`beanFactory.preInstantiateSingletons();`

直接执行，将所有的 单例bean实例化。

## 6.8 finishRefresh 完成刷新

`finishRefresh();`

spring 提供的 Lifecycle 接口，包含 Star/Stop方法。实现接口，Spring 会保证 在启动的时候调用其Star方法，关闭时调用Stop方法，通常用来配置后台程序。

```java
	protected void finishRefresh() {
		// Initialize lifecycle processor for this context.
        // 初始化 
		initLifecycleProcessor();

		// Propagate refresh to lifecycle processor first.
        // 启动 所有的 实现了Lifecycle接口的 bean
		getLifecycleProcessor().onRefresh();

		// Publish the final event.
        // 触发 事件
		publishEvent(new ContextRefreshedEvent(this));

		// Participate in LiveBeansView MBean, if active.
		LiveBeansView.registerApplicationContext(this);
	}
```

