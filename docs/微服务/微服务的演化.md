[[TOC]]

## 服务的演变

1. 最开始的单体服务
2. 业务的成熟性能问题：一种解决办法，**多级缓存**（本地缓存 服务缓存），IO瓶颈出现 和 服务调用，
3. 单点服务的问题：服务挂掉  并发高。 **单体服务变多节点服务**
4. 客户端请求如何分配到多节点服务：**复杂均衡** LVS 4层网络模型，没有三次握手 **高可用** 
5. 多节点之间的状态管理（分布式问题）：**服务的无状态设计** 动态扩缩容
6. 多节点服务后过于臃肿，每个服务是全量的 压力问题：线程池隔离 **拆解服务** 
7. 服务的认知：nginx 静态页面 **反向代理 + 负载均衡** 根据用户不同的请求不同URI 分析
8. nginx 是有上限的5W：前 再加 LVS  nginx  做集群 流露接入层
9. 微服务：**AKF** XYZ 轴划分服务
10. 微服务的治理：**分布式 解决方案**
11. 负载均衡同一个资源时：**锁** **分布式锁**  TPS redis 单体 4-6W    zk 集群 1W   etcd ，加锁 直接降一个数量级
12. 网关层 zuul gateway，反向代理 与 负载均衡后的就是网关层，由各个网关控制 具体到什么服务上
13. 熔断 降级 限流 sentinel ，基于QPS 限流，与 网关层 集成，服务能接受多少流量，sentinel  之间统一数据通信 某个服务QPS上线，到了后 **执行拒绝策略**， 动态限流 sentinel 是不支持的，需要二次开发。histrix  侵入强，基于线程进行限流，开了很多线程池
14. 配置中心：spring config、Apollo、Nacos，服务启动时，先链接 配置中心，拿到服务名、配置Key（例如 当前服务的QPS 上限），配置发生变化后，后两者为 **长轮询** 超时时间60s

> 正向代理，请求者清楚需要代理才能访问
> 
> 反向代理，请求者请求后，由代理服务进行转发返回数据
> 
> 负载均衡：服务是镜像的
> 
> 反向代理：服务是 分片 分治的
> 
> 一个请求，性能变低
> 
> 不同请求 走不同路径 并行
> 
> 同一类型业务 锁的争抢
> 
> redis 同一类型的请求 对应一个Key 锁，而 同一类型的请求 是可以划分（Z轴划分） 不同的Key（redis  不是的功能不同） 进行并行

微服务4个原则：

1. AKF
2. 服务无状态设计
3. 通信无状态
4. 前后端分离