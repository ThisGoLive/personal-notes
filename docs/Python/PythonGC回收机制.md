# Python GC机制

引用计数器为主 

标记清除和分代回收 为辅 + 缓存机制



## 1 引用计数器

### 1.1 双向链表

C 中的 **双向链表 refchain**， 在python 中创建的任何 对象 都会 被添加到 该链表中， 获取了 该 链表 就相当于获取的 python 的全部对象。

当 python 中创建了一个对象后， 链表中 创建一个结构体（struct） 

+ 上个对象的指针 
+ 下个对象的指针 
+ 本对象的类型 
+ 引用个数 ob_refcnt
+ 本对象的其他值

### 1.2 计数器

C源码中结构体：PyObject PyVarObject 

PyObject 中 ob_refcnt ，在 创建 python对象时，默认为1。 被引用时改变

当 ob_refcnt  为0时，链表删除，对象 回收 （还有缓存）



## 2 标记清除

但是 引用计数器 无法解决 循环引用 的问题。

在 python 底层 再维护一个 链表。放 可能存在循环引用的对象，即 对象中 能再放其他对象的。例如 list tuple dict set 扩展类

在 python 内部 某种情况下，去 扫描 第二个链表，如果有 循环引用的对象，就会 将 引用计数器 减一

## 3 分代回收

+ 什么时候 去扫描 第二个链表

+ 扫描一次 会很耗时

第二个链表 维护为 三个子链表：  

+ 0代  个数 达到700 个时
+ 1代  0代扫描10次
+ 2代 1代扫描10次

## 4 缓存机制

### 4.1 池（int 字符串）

为了避免重复 创建 与 销毁 常见对象。可以理解为 Java 中的常量池

int 类型默认创建 -5 -4 .... 256

### 4.2 free_list （float list tuple dict）

引用计数器为0 时，按理回收，但是 不会回收。而是 将对象 添加到 free_list 中当中缓存。以后在创建对象时，不再重新开辟内存。

但是 free_list 并不会无限添加，而是有个数限制。